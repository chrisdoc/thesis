<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Generating Driving Trajectories for Mobile Subscriber</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
</head>
<body>
<div id="header">
<h1 class="title">Generating Driving Trajectories for Mobile Subscriber</h1>
</div>
<p><span> backgroundcolor=, basicstyle=, frame=b, xleftmargin=<span>0.75cm</span>, numbers=left, stepnumber=1, firstnumber=1, numberfirstline=true, identifierstyle=, keywordstyle=<strong>, ndkeywordstyle=<strong>, stringstyle=, commentstyle=, language=HTML5, alsolanguage=JavaScript, alsodigit=<span>.:;</span>, tabsize=2, showtabs=false, showspaces=false, showstringspaces=false, extendedchars=true, breaklines=true, literate= <span>Ö</span><span><span>Ö</span></span>1 <span>Ä</span><span><span>Ä</span></span>1 <span>Ü</span><span><span>Ü</span></span>1 <span>ß</span><span><span>ß</span></span>1 <span>ü</span><span><span>ü</span></span>1 <span>ä</span><span><span>ä</span></span>1 <span>ö</span><span><span>ö</span></span>1 </strong></strong></span> <span> backgroundcolor=, basicstyle=, frame=b, xleftmargin=<span>0.75cm</span>, numbers=left, stepnumber=1, firstnumber=1, numberfirstline=true, identifierstyle=, keywordstyle=<strong>, ndkeywordstyle=<strong>, stringstyle=, commentstyle=, language=HTML5, alsolanguage=JavaScript, alsodigit=<span>.:;</span>, tabsize=2, showtabs=false, showspaces=false, showstringspaces=false, extendedchars=true, breaklines=true, literate= <span>Ö</span><span><span>Ö</span></span>1 <span>Ä</span><span><span>Ä</span></span>1 <span>Ü</span><span><span>Ü</span></span>1 <span>ß</span><span><span>ß</span></span>1 <span>ü</span><span><span>ü</span></span>1 <span>ä</span><span><span>ä</span></span>1 <span>ö</span><span><span>ö</span></span>1 </strong></strong></span></p>
<h1 id="introduction">Introduction</h1>
<h2 id="problem-description">Problem Description</h2>
<p>Traffic analysis is an import part in road network and mobile network simulations. These simulators require moving subscribers in order to investigate interesting effects in their networks. Moving subscribers can be generated from mobility models which try to describe the mobility of individuals.</p>
<p>This work focuses on estimating trajectories for mobility simulations by using mobile subscription data. A trajectory describes the path of a moving object through space as a function of time. Network operators need moving subscribers to evaluate and analyze an existing or a virtual network. Replay scenarios can be created to investigate the current or a new network with a scenario where errors accrued. The trajectory generation process involves several tasks. First useful events have to be filtered in the network. The users path has to be estimated, which involves the start and end position as well as the handover position.</p>
<p>Another part of this thesis is to estimate the coverage area for each cell sites. The coverage area is a crucial aspect in trajectory estimation. Trajectories need the location of a subscriber as a function of time. However GSM doesn’t expose an accurate position of the subscriber. Therefore a good representation of the coverage area allows to narrow the users position in the network. The problem is to find an approach which creates a good estimation of the coverage area for each cell site.</p>
<h2 id="motivation">Motivation</h2>
<p>In the last years mobile network simulations have to adopt to the mobility of the subscribers. Subscribers are not stationary and therefore behavior models have to be defined. These models shall represent the entire subscriber database.</p>
<p>Since the beginning of mobile network simulations random walk and manhattan grid approaches were used to enable mobility. The problem is that random walk and manhattan grid rely on statistical data. The statistical input used is derived from household surveys. This surveys however only depict a special moment in time. To evaluate or gather more moments numerous surveys have to be done.</p>
<p>Our approach is different, instead of surveys we are using mobile subscriber data. More precise call data records. The motivation behind using mobile subscriber data is that this data represents all users of the mobile network operator. We want to use this data to generate anonymous driving trajectories. The use of call data records allows the generation of trajectories for each day and time of the year. The generated trajectories adopt to daily as well seasonal changes.</p>
<h2 id="challenges">Challenges</h2>
<p>The first challenge we have to face is that we don’t have a model of the coverage area for all cell sites. Therefor we need a good representation to estimate a coarse position for each subscriber. In order to generate a trajectory the users start and end position are crucial. At first we only have the serving cell and a representation of its serving area. Therefore the position of the user within the cell has to be estimated. For this purpose we are using a combination of population and land use information data.</p>
<h2 id="goals">Goals</h2>
<p>The main goal is to generate trajectories for each mobile subscriber. However due to the design of GSM we can only generate trajectories for mobile users which are in an active call. Additionally we are investigating approaches to annotate the driving trajectories with timing information. In the end we are also examining methods to improve the representation of the serving area with public available data (digital elevation model, land use clutter information,...).</p>
<h2 id="structure">Structure</h2>
<p>At first we are discussing state of the art approaches to estimate driving trajectories and mobility in mobile network simulations. Followed by an overview of fundamental concepts and techniques used in this thesis. The third part explains our concept and approach which will be implemented in the succeeding chapter. At last we will present and discuss our results and give a summary of the work.</p>
<h1 id="related-work">Related Work</h1>
<p>The following chapter presents state-of-the-art approaches and projects related to user mobility and traffic analysis. These projects are used to derive the mobility of mobile subscribers by investigating events in mobile operator networks. They differ from classical behavior analysis in terms of penetration and accuracy. To derive the behavior of the entire population surveys and origin-destination matrices have been used in traffic modeling since the early 1960s.</p>
<p>Starting in the late 1990s floating phone data (FPD) has gained interest in traffic estimation and congestion detection. FPD is used due to its high penetration rate, in Austria the market penetration was <span class="LaTeX">$159\%$</span><a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> in 2013. There is a large volume of published studies describing the role of FDP for traffic analysis <span class="citation">\cite{Yim2001,Qiu2007,Caceres2008}</span>.</p>
<p>The approaches that will be presented here have a higher penetration rate due to the fact that they investigate a whole network whereas surveys can only cover parts of the entire network. Another advantage of these approaches is the adaption to seasonal changes. Surveys only depict the behavior at a certain point in time. However both road and mobile network traffic modeling depend on changes in time. By exploring events in mobile operator networks, the behavior can be analyzed for every point in time.</p>
<h2 id="evaluation-of-a-cellular-phone-based-system-for-measurements-of-traffic-speeds-and-travel-times-a-case-study-from-israel">Evaluation of a cellular phone-based system for measurements of traffic speeds and travel times: A case study from Israel</h2>
<p>To measure the traffic speed and travel time in Israel Bar-Gera <span class="citation">\cite{Bar2007}</span> used a proprietary system by Estimotion Ltd. The system works with handover updates to derive the traveled route and traffic speeds. A sequence of locations derived from the handover footprint is matched to road segments which appear to be the most likely on the road network. An example of a handover sequence and its footprints on the road network is shown in Fig.  [fig:bar]. Despite the fact that this is a proprietary system it gives a good overview of the capabilities of floating phone data. The work by Bar-Gera shows that travel time estimation with phone data can be a replacement for loop magnetic detectors. He investigated a road segment from January to March 2005 and found that the average absolute relative difference between the two systems is <span class="LaTeX">$10.7\%$</span>. However the whole system has its limitations due to the noise generated by floating phone data. They could reduce the noise by combining travel speeds from subscribers that traveled on the same road segment.</p>
<p><embed src="images/bar.pdf" title="fig:" /> [fig:bar]</p>
<h2 id="generating-trajectories-from-mobile-phone-data">Generating Trajectories from Mobile Phone Data</h2>
<p>To derive trajectories form mobile subscribers Schlaich et al. <span class="citation">\cite{Schlaich2010a}</span> used location area sequences. Location area update events are issued whenever a mobile subscriber enters a new location area. These events are issued in both connected and idle states. Therefore trajectories can be generated even when no call is ongoing. Due to the small number of location areas in the research area, each location area was represented by a unique character. This allowed storing a location area sequence as a string. The next step was to generate routes in the research area and store the location area characters for each area they traversed. To estimate a trajectory for a mobile subscriber the location area sequence for the subscriber was compared to route sequences that have been generated before. Fig. [fig:schlaichcomp] depicts the comparison of a mobile subscriber sequence and route sequences with high similarity.</p>
<p><embed src="schlaichcomp.pdf" title="fig:" /> [fig:schlaichcomp]</p>
<p>The results showed that this technique works well for longer trips around 20 kilometers because trips can only be estimated if the number of different location areas is greater than 3. Schlaich et al. also stated that the presented approach only generates trajectories for sim cards and not for vehicles. A vehicle can have none, one or more sim cards therefore a vehicle can generate <span class="LaTeX">$0..n$</span> trajectories where <span class="LaTeX">$n$</span> is the number of sim cards within the vehicle.</p>
<p>Schlaich <span class="citation">\cite{Schlaich2010}</span> later used this technique to observe the route choice behavior in the Stuttgart, Germany area. It has shown that drivers react to traffic news broadcasts and variable message signs (VMS). However the acceptance of a route displayed on a VMS was only between <span class="LaTeX">$3$</span> and <span class="LaTeX">$17\%$</span>.</p>
<h2 id="route-choice-estimation-based-on-cellular-signaling-data">Route Choice Estimation Based on Cellular Signaling Data</h2>
<p>To overcome the use of origin-destination matrices Tettamanti et al. <span class="citation">\cite{Tettamanti2012}</span> used a simulation framework and a route generator to generate trajectories for mobile subscribers. Instead of using location area updates as Schlaich et al. did they used handover updates. Handover updates allow to generate trajectories not only for a higher road network but also for the minor one. Their approach is based on cell area estimation as each handover update reveals the current cell area. Whenever a mobile phone reaches the boundary of the currently connected cell or when another cell has a higher reception then a handover is made to a cell with a better reception. Tettamanti et al. used Voronoi partitioning to calculate the coverage area for each cell site to estimate a coarse user position.</p>
<p>The main limitation when using handover updates is that a handover update is only propagated when the mobile phone is in connected mode (during a call).</p>
<p>The start and end of the trajectory were set by the centroid of the cell where the call originated and terminated. To derive routes, a traffic modeling simulation framework <em>VISSIM</em> was used. VISSIM was used to generate routes between the start and the end of the call. For each of the generated routes, the euclidean distance between each of the cell sites and the generated route was calculated. To compare different routes equation [eq:sumsquare] was used as a metric. For each route <span class="LaTeX">$j$</span>, the squared sum of all minimum distances <span class="LaTeX">$d_{i,j}$</span> between the route and the cell site was calculated. The route with the minimum sum was used as a trajectory for the subscriber. In Fig. [fig:tettaroutes] an example for four different routes which were generated by VISSIM can be seen. Tab. [tab:tetta] depicts the results of the above stated equations (see Equation. [eq:sumsquare]). In this example route 4 (see Fig. [fig:tettaroutes](d)) had the smallest squared sum of all four routes.</p>
<p><span class="LaTeX">$$\label{eq:sumsquare}
D_j=\sum_{i=1}^{m} d_{i,j}^{2}$$</span></p>
<p><span class="LaTeX">$$\label{eq:minsum}
min(D_j), j = 1,2,\ldots,n$$</span></p>
<p><span>cc</span> <embed src="tattipath0.pdf" /> &amp; <embed src="tattipath1.pdf" /><br />(a) first &amp; (b) second<br /><embed src="tattipath2.pdf" /> &amp; <embed src="tattipath3.pdf" /><br />(c) third &amp; (d) fourth<br /></p>
<p>[fig:tettaroutes]</p>
<p>[h]</p>
<table>
<thead>
<tr class="header">
<th align="left">Route <span class="LaTeX">$j$</span></th>
<th align="left"><span class="LaTeX">$D_j=\sum_{i=1}^{m} d_{i,j}^{2}$</span></th>
<th align="left">Ratio compared to the lowest value</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">5130283</td>
<td align="left">8.2</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">3097741</td>
<td align="left">4.9</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">1356076</td>
<td align="left">2.2</td>
</tr>
<tr class="even">
<td align="left"><strong>4</strong></td>
<td align="left"><strong>627122</strong></td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>[tab:tetta]</p>
<p>The research by Tettamanti et al. showed that trajectories can be generated for mobile subscribers by analyzing their handover events. This can be done without using special equipment and can be used to investigate the travel behavior for many subscribers.</p>
<h2 id="roadcell-road-traffic-estimation-from-cellular-network-signaling">RoadCell – Road Traffic Estimation from Cellular Network Signaling</h2>
<p>By using cellular network monitoring and therefore mobile subscription data Valerio et al. <span class="citation">\cite{Valerio2009,Valerio20092}</span> at the FTW Forschungszentrum Telekommunikation Wien GmbH are investigating road networks in Austria. <em>RoadCell</em><a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a> is using the same mobile subscription data source as our system <span class="citation">\cite{RoadCell2009}</span>. The aim of <em>RoadCell</em> is to recognize situations in the traffic flow by analyzing events in the core network of the mobile network operator. Driven by the fact that each road user is also a subscriber of a cellular network, network operator can be seen as another source to gather traffic information. Their motivation is to provide road operators with an inexpensive toolkit to observe the traffic flow without the installment of costly sensors. Thereby it is possible to not only investigate the traffic flow on the higher road network but also on minor roads where the installment of dedicated sensors cost-effective.</p>
<p>The idea is to observe changes in network signaling events and extract road conditions for example: drop in the handover rate;abrupt change in the LR update; (c) increase in the number of calls/SMS; change in the number of road users. Figure [fig:raodcell<sub>a</sub>ccident] shows how an accident effects the amount of Routing Area Update (RAU) and Location Area Update (LAU). An accident is indicated by sharp decrease in RAU and LAU events followed by a sharp increase in RAU an LAU events.</p>
<p><img src="./images/raodcell_accident" title="fig:" alt="Effect of the accident on the number of combined RAU and LAU; tic=300s " /> [fig:raodcell<sub>a</sub>ccident]</p>
<p>Figure [fig:roadcell] depicts the system overview of the <em>RoadCell</em> project. It can be seen that, despite cellular network data, there are additionally data sources used. In order to map a particular event to a road segment, they are using coverage predictions from the network operator. To support data processing they are using third-party sources like floating car data from taxis and public transports which are more accurate, but have a lower penetration rate.</p>
<p><img src="./images/roadcell" title="fig:" alt="RoadCell System Overview " /> [fig:roadcell]</p>
<p>During their research found out that a combination of passive and active tracking is best to observe road conditions. Passive tracking is done without the involvement of the mobile station. This approach only utilizes the events captured in the operators core network. While passive tracking offers a high penetration and no increase in network load, it is less accurate than active tracking. Active tracking requires the mobile station and core network to exchange special events that allow the network operator to get an accurate position of the mobile station. This technique is known as Time Difference of Arrival (TDOA). Valerios proposal is to use a combination of both; passive tracking is always used and once the system detects a possible accident active tracking is used for the area in which the accident occurred. This approach improves the accuracy while trying to minimize the additional network load introduced by active tracking.</p>
<h1 id="cha:fundamentals">Fundamentals</h1>
<p>This chapter covers fundamentals that are necessary for a better understanding of the concepts presented in this work. It gives a short introduction into mobile communications systems which our system uses. Mobile communications systems are used in our system to estimate the users coarse location. Furthermore, state of the art analytical mobility models for mobile network simulations are presented. Another section covers the data (provided by A1) our system is using to generate driving trajectories. At last, the process to estimate the coverage area for cell sites with Voronoi tessellation is shown.</p>
<h2 id="mobile-communication-networks---gsm">Mobile Communication Networks - GSM</h2>
<p>Mobile communication networks are the basis of our modern communication and interaction. However the beginning of wireless communication began in the late and was shaped by the work of Hughes, Maxwell, Hertz, Tesla and Faraday.</p>
<p>In 1982, a new mobile communication network was developed by the Group Spécial Mobile of the CEPT (Conférence Européenne des Administrations des Postes et des Télécommunications). The main goal of GSM was to develop a Europe-wide standard for digital mobile communication. Over the past two centuries, there has been a rapid increase in the use of GSM all over the world. The present section is based on the books <em>GSM: Switching, Services and Protocols</em> by Jörg Eberspächer et al. <span class="citation">\cite{Eberspaecher2001}</span> and <em>Mobilfunknetze und ihre Protokolle 1</em> by Bernhard Walke <span class="citation">\cite{Walke2001}</span>.</p>
<p>Besides GSM, there are other mobile communication currently in use. These systems are known as 3G (UMTS, HSPA, WCDMA, etc. ) and 4G (LET, LTE Advanced, etc. ) networks whereas GSM is a network of the second generation (2G).</p>
<h3 id="components---system-architecture">Components - System architecture</h3>
<p>GSM consists of a large number of components which are necessary for its operation. However, we will only focus on components that are necessary to understand the functionality of our system. The overview of a GSM network with GPRS capability is visible in Fig. [fig:GSMNetwork]. The various standardized interfaces which are responsible for communication between the components can be seen as well as the different components of the <em>Radio Access Network</em> RAN and the <em>Core Network</em> CN. The RAN consists of a BTS and BSC in GSM and a Node B and a RNC in GPRS.</p>
<p><img src="./images/GSMNetwork" title="fig:" alt="System overview of the a GPRS Network" /> [fig:GSMNetwork]</p>
<h4 id="mobile-station---ms">Mobile Station - MS</h4>
<p>Mobile stations are the equipment used by mobile subscribers to access services provided by the network operator. The mobile station consist of two components, first the <em>Mobile Equipment</em> and second the <em>Subscriber Identity Module</em> (SIM). The SIM grants a mobile subscriber access to the network and allows to initiate or receive calls. For management purposes GSM assigns the following numbers and identities to a MS:</p>
<ul>
<li><p><strong>IMSI</strong> International Mobile Station Identity</p></li>
<li><p><strong>TMSI</strong> Temporary Mobile Station Identity</p></li>
<li><p><strong>MSISDN</strong> Mobile Station International ISDN Number</p></li>
<li><p><strong>MSRN</strong> Mobile Station Roaming Number</p></li>
</ul>
<h4 id="base-transceiver-station---bts">Base Transceiver Station - BTS</h4>
<p>The BTS provides the radio channels for signaling and user traffic data with in a cell. The mobile station establishes a connection with the BTS over the air interface. The BTS consists only of a few parts, the high-frequency equipment (transceiver and receiver) and the signaling and protocol processing unit. The control remains in the BSC.</p>
<h4 id="base-station-controller---bsc">Base Station Controller - BSC</h4>
<p>A BSC is used to manage one or more BTS. It is directly connected to a MSC. Together with the BTS, the BSC forms the <em>Base Station Subsystem</em> (BSS). For example, the BSC executes the handover protocol and switches a MS to a new BTS.</p>
<h4 id="mobile-switching-center---msc">Mobile Switching Center - MSC</h4>
<p>The MSC together with the databases (HLR, VLR) forms the <em>Mobile Switching System</em> (MSS). The MSC is responsible for the switching in the network. For example, the MSC performs signal routing, routing path search and service processing. Additionally the MSC has to pay attention to the allocation and administration of radio channel and the mobility of subscribers. A <em>Public Land Mobile Network</em> (PLMN) can consists of several MSCs where each is responsible for a dedicated area. Furthermore, the MSC is connected to a <em>Gateway Mobile Switching Center</em> (GMSC) which forwards voice traffic between fixed and mobile networks. The GMSC enables the subscriber to call subscribers in different MSCs or PLMNs.</p>
<h4 id="visited-location-register---vlr">Visited Location Register - VLR</h4>
<p>The VLR stores information of all MS who are located in the serving area of the associated MSC. A VLR can be assigned to one or more MSCs. A MS can be registered in a VLR of its home PLMN or a foreign one when a roaming agreement exists.</p>
<h4 id="home-location-register---hlr">Home Location Register - HLR</h4>
<p>Typically, there is one HLR per PLMN and one VLR for each MSC. The HLR stores all permanent and temporary subscriber information for all registered subscribers. Moreover, it stores a coarse current location of each MS. The HLR operates as a central register needed by the MSC for routing of subscribers.</p>
<h3 id="radio-resource-management---rr">Radio Resource Management - RR</h3>
<p>The GSM standard <span class="citation">\cite{Etsi1994}</span> distinguishes between two modes of operation first idle and second connected mode. The radio resource management is necessary to manage the physical and logical channels.</p>
<h4 id="idle-mode">Idle Mode</h4>
<p>In idle mode there is no dedicated channel assigned to a MS. However, the MS listens on signaling channels (BCCH and CCCH). The higher layers are only informed when a MS reaches the boundaries of a location area.</p>
<h4 id="subsub:connected">Connected Mode</h4>
<p>In this mode there are two dedicated channels assigned to the MS, the first one is SACCH and the second one is either FACCH or SDCCH. The radio resource management provides the following service to a connected MS (a full list can be found in ETSI GSM 04.08 <span class="citation">\cite{Etsi1994}</span>):</p>
<ul>
<li><p>Transfer of messages on any data link layer</p></li>
<li><p>Establishment/release of multiframe mode on SDCCH, FACCH or SACCH.</p></li>
<li><p>Automatic cell reselection and handover to maintain the RR-connection</p></li>
</ul>
<h3 id="handover">Handover</h3>
<p>A handover is the transfer of an established connection to a new BTS. A handover is necessary for various reasons. First of all, a handover decision is made by the GSM network and not by the MS. As mentioned before the handover protocol is implemented in the BSS. The BSS decides to initiate a handover based on BSS criteria (channel quality, received signal level, distance between MS and BTS) and network criteria (e.g. traffic load of the network).</p>
<p>Handovers are only performed when the MS is in connected mode. If the MS is in idle mode and reaches the boundaries of the cell a location area update is performed if the new cell is in a different location area.</p>
<p>The GSM standard does not define an algorithm for handover decision. Therefore, network suppliers are responsible for implement them. A basic handover algorithm is specified in appendix A of the ETSI GMS 05.08 <span class="citation">\cite{Etsi19942}</span>.</p>
<h5 id="intra-cell-handover">Intra-Cell-Handover</h5>
<p>The channel within the cell will be changed, e.g. when the channel is noisy. The change can either be done to a new frequency or to a new time-slot with the same (old) frequency.</p>
<h5 id="inter-cellintra-bsc-handover">Inter-Cell/Intra-BSC-Handover</h5>
<p>The channel will be changed between two cells within the same BSC.</p>
<h5 id="intra-cellintra-msc-handover">Intra-Cell/Intra-MSC-Handover</h5>
<p>The connection will be changed between two cells in different BSCs, but both are managed by the same MSC.</p>
<h5 id="inter-msc-handover">Inter-MSC-Handover</h5>
<p>The connection will be changed between two cells that are managed by different MSCs.<br /></p>
<p>The first two handovers can be carried out by the BSC if it supports the handover protocol. If this is not the case then also Intra-Cell-Handover have to be carried out by the MSC.</p>
<h5 id="ping-pong-handover">Ping-pong Handover</h5>
<p>A ping-pong handover is an undesirable effect where a handover is made to a neighbor cell and after short time back to the original cell <span class="citation">\cite{Junius1995}</span>.</p>
<h3 id="location-area-updates---lau">Location Area Updates - LAU</h3>
<p>Location area updates are used to ease the localization of mobile subscribers. Therefore, a MS must initiate a location area update once it leaves the location area. The HLR and VLR both store the current location area. A MS constantly measures the received signal strengths of all surrounding BTSs and reports it to the BSS to the one with the highest signal strength. If it connects to a BTS outside of the current location area then the MS initiates a location area update and tells the CN its new location area. There are two cases which can distinguished:</p>
<ul>
<li><p>change within the same VLR</p></li>
<li><p>change to a new VLR</p></li>
</ul>
<h4 id="location-area---la">Location Area - LA</h4>
<p>A location area defines the area within the mobile network in which the mobile subscriber is located. Location areas are used to decrease the signaling necessary to locate a mobile subscriber within the network. Without location areas, the PLMN has to initiate a paging request to all BTSs. By using location areas, only the BTS within the location area have to carry out the paging request.</p>
<p><img src="./images/locationarea" title="fig:" alt="Example for three location areas" /> [fig:locationarea]</p>
<p>One or more BTS with the same MSC can be part of one location area, in most cases they are part of the same BSC. Fig. [fig:locationarea] shows that a location area can consists of several BTS. Each location area is uniquely defined by the <em>Location Area Identity</em> (LAI). The LAI (see Tab. [tab:lai]) consists of the Mobile Country Code (e.g. Austria 232) which identifies the country, the Mobile Network Code (e.g. A1 1) which identifies the PLMN and the Location Area which identifies the location area within the PLMN. Together with the Cell-ID (CID) the LAI forms the Global Cell-ID (GCID). The size of a location area depends on:</p>
<ul>
<li><p>Cell density</p></li>
<li><p>Voice and data traffic</p></li>
<li><p>Network operator configuration</p></li>
</ul>
<p><span>|c|c|c|</span><br />Mobile Country Code &amp; Mobile Network Code &amp; Location Area Code<br />3 digits &amp; 2 or 3 digits &amp; 5 digits<br /></p>
<p>[tab:lai]</p>
<h4 id="updates">Updates</h4>
<p>For its operation the MSC (HLR, VLR) needs to know where the mobile subscriber is located. Therefore, location area updates are required. There are two kinds of location area updates first normal updates and second periodic updates. Normal location area updates (NLAU) happen either when the MS is switched on or off during an IMSI attach/detach or when a MS connects to a new BTS in a different location area. Periodic location area updates (PLAU) are defined by the network operator. Each MS has a PLAU timer for this purpose, whenever the timer expires the MS performs a PLAU.</p>
<h3 id="antennas">Antennas</h3>
<p>Antennas enable wireless communication between a receiver and a transmitter. In GSM, they are the direct air interface between the MS and the Radio Access Network (RAN). Antennas can be designed to transmit or receive signals equally in all directions (omni-directional antennas) or transmit and receive signals in a specific direction (directional or high gain antennas). In GSM networks, a combination of both is used. Omni-directional are mainly used in rural areas to cover a large area whereas directional antennas are used to cover a smaller area with a higher traffic load.</p>
<h4 id="sector">Sector</h4>
<p>Sector antennas are a special use case of directional antennas where several directional antennas are combined and each covering a particular sector such as a <span class="LaTeX">$120\,^{\circ}$</span> horizontal pattern. In GSM the most common installations of sector antennas are <span class="LaTeX">$60\,^{\circ}$</span>, <span class="LaTeX">$90\,^{\circ}$</span> and <span class="LaTeX">$120\,^{\circ}$</span>. Based on the traffic load, smaller sectors can be used with larger ones on the same tower (e.g. two <span class="LaTeX">$60\,^{\circ}$</span> antennas with two <span class="LaTeX">$120\,^{\circ}$</span> antennas).</p>
<h4 id="antenna-size">Antenna size</h4>
<p>The antenna size or more general its coverage is defined by the antenna gain, the antenna characteristics and the transmit power. In mobile communication networks there are four different types of cells in use that are distinguished by their coverage.</p>
<h5 id="macrocell">Macrocell</h5>
<p>Provides the primary radio coverage for mobile networks. Macrocell antennas are mounted on ground-based towers, buildings or other existing infrastructure in order to have a clear view over the coverage area.</p>
<h5 id="microcell">Microcell</h5>
<p>A microcell offers additional capacity within the coverage of a macrocell. Typically, microcell antennas are mounted at street level. Microcells have lower output power than macrocell and therefore a decreased coverage (e.g. 300 to 1000 meters).</p>
<h5 id="picocell">Picocell</h5>
<p>To provide coverage inside buildings or to a high numbers of users. The coverage of a picocell is 200 meters or less.</p>
<h5 id="femtocell">Femtocell</h5>
<p>A low-powered, coverage is on the order of 10 meters, base station designed for use in a home or small business <span class="citation">\cite{Zhang2011}</span>.</p>
<h2 id="mobile-network-mobility-simulations">Mobile Network Mobility Simulations</h2>
<p>Mobile networks permit its subscribers to move freely within the coverage area. To evaluate and ensure the mobility, mobile network operators need to understand the user mobility. A user mobility can be described by a mobility model. A mobility model describes the user behavior and activity using simulation and analytic models. Simulation models are based on realistic mobility scenarios whereas simplified assumptions about the users movement behavior are the foundation of analytic models.</p>
<p>Two major analytic models which are used in mobile network simulation are the <em>Random Walk</em> <span class="citation">\cite{Akyildiz2000,Bettstetter2001,Bettstetter2002}</span> and the <em>Manhattan Grid</em> <span class="citation">\cite{Markoulidakis1997}</span>.</p>
<h3 id="random-walk">Random walk</h3>
<p>The mobility of entities in nature is unpredictable, therefore a variety of models exists in literature. These models try to describe the mobility for different scenarios. The random walk model is a memory-less system and maintains no record of previous locations and speed. In each iteration dices a new direction and speed within a predefined range <span class="citation">\cite{Camp2002}</span>. An example for a generated random walk is depicted in Fig. [fig:randomwalk]. The speed is limited to the interval <span class="LaTeX">$0..5$</span> and angle is limited to <span class="LaTeX">$-15..15^\circ$</span>. The mobility of entities in nature is unpredictable, therefore a variety of models exists in literature. These models try to describe the mobility for different scenarios. The random walk model is a memory-less system and maintains no record of previous locations and speed. In each iteration dices a new direction and speed within a predefined range <span class="citation">\cite{Camp2002}</span>. An example for a generated random walk is depicted in Fig. [fig:randomwalk]. The speed is limited to the interval <span class="LaTeX">$0..5$</span> and angle is limited to <span class="LaTeX">$-15..15^\circ$</span>.</p>
<p>[ymin=0,xlabel=<span>meter</span>,ylabel=<span>meter</span>,title=<span>Random Walk</span>] table[mark=none]<span>random.csv</span>;</p>
<p>[fig:randomwalk]</p>
<h3 id="manhattan-grid">Manhattan Grid</h3>
<p>In a Manhattan grid scenario streets are aligned in a square grid. It is named after the district Manhattan in the City of New York. Fig. [fig:manhattan] shows a map of Manhattan and its road network. It can be seen that roads consist of straight lines and each junction forms a right angle.</p>
<p>The Manhattan Grid mobility model can work on any road network. At each junction, the logic is executed which decides if the current street shall be used or a different one. The logic can be modeled as a random number generator with a defined probability density function. For example the probability to drive straight can be <span class="LaTeX">$60\%$</span>, turn right <span class="LaTeX">$30\%$</span> and turn left <span class="LaTeX">$10\%$</span>. The Manhattan Grid mobility model is an extension to the random walk model where participants are not allowed to move freely, but rather move on a defined road network.</p>
<p><img src="./images/manhattan" title="fig:" alt="Manhattan Road Network" /> [fig:manhattan]</p>
<h2 id="a1-data">A1 Data</h2>
<p>We are using mobile subscription data from A1. A1 is the largest network operator in Austria with <span class="LaTeX">$5.3$</span> million subscribers. The used data was recorded on the network of A1 between Monday, November 2010 and Sunday, November 2010. The captured interfaces, events and the data structure of the system will be depicted in the succeeding subsections.</p>
<p>Fig. [fig:distevents] shows the distribution of events for Monday, November 2010. It can be seen from this that the distribution for handover events is not the same as for mobile originated calls. A strong increase of handover events (see Fig. [fig:disthandover]) takes place at 17 o’clock. This is due to the end of work of subscribers. People are leaving from work and start calling there friends while on their way home. On the other hand, a strong decrease of call activity (see Fig. [fig:distmoc]) takes place between 12 and 13 o’clock where people are having lunch.</p>
<p>[b]<span>0.5</span> <img src="hauf_event_32_time_mat" title="fig:" alt="Handover Events" /> [fig:disthandover]</p>
<p> </p>
<p>[b]<span>0.5</span> <img src="hauf_event_34_time_mat" title="fig:" alt="Mobile Originated Calls" /> [fig:distmoc]</p>
<p>[fig:distevents]</p>
<h3 id="system-architecture">System Architecture</h3>
<p>Monitoring units need to be installed in the Core Network of A1 to capture useful events. Fig [fig:A1Network] illustrates the system architecture used by A1 to capture events. The architecture is almost the same as for a typical GSM system, the only differences are the monitoring units responsible for capturing and forwarding events. In order to intercept the network, the monitoring units are attached to the main interfaces (A, IuCS, Gb/IuPS, IuPS) of the Core Network. The processing unit is responsible for aggregating events and ensuring anonymity.</p>
<p><img src="./images/A1Network" title="fig:" alt="System Architecture of the A1 Monitoring System" /> [fig:A1Network]</p>
<h4 id="interfaces">Interfaces</h4>
<p>The monitoring units capture both <em>Circuit Switched</em> (CS) and <em>Packed Switched</em> (PS) data. Therefore, it intercepts the communication of CS and PS interfaces. The CS interfaces are A and IuCS and they belong to the MSC and enable voice calls and sms. The PS interfaces are the Gb/IuPS and the IuPS. Both are connected to the SGSN and enable subscribers to use packed orientated services (e.g. Internet).</p>
<h3 id="sec:dataa1">Data Structure</h3>
<p>Each event captured by the monitoring unit is forwarded to the processing unit for further aggregation. An event is encoded into a binary format and then forwarded to thr consumer. Each event has a fixed length (88 bytes) and its structure is shown in Fig. [fig:a1structure]. Because not all fields were used by our system, only the ones used are described.</p>
<h4 id="sec:anonymous">Anonymous ID</h4>
<p>This 32 bytes field contains a unique anonymous identifier of the mobile terminal. It changes every day at midnight, i.e. a device can be followed for maximum 24 hours time span before the assigned anonymous ID changes.</p>
<h4 id="timestamp">Timestamp</h4>
<p>The timestamp represents the exact time of occurrence of the event (i.e., the instant when the event has been captured by the monitoring unit).</p>
<h4 id="latitude-and-longitude">Latitude and Longitude</h4>
<p>These two fields represent the position of the BTS in which the event occurred. They are both encoded as decimal numbers representing the WGS84 coordinates in degrees. The decimal number is encoded according to IEEE 754 floating-point double format<span class="citation">\cite{IEEE754}</span>.</p>
<h4 id="event-type">Event type</h4>
<p>Every event includes a field (i.e., Event type) that indicates which type of event has been detected. All possible signaling events are described in Table [tab:eventtype].</p>
<h4 id="angle">Angle</h4>
<p>This field defines the installment of a sector antenna. It is the angle at which the antenna is mounted on the mast. Fig. [fig:antennaangle] illustrates the mounting of a directional antenna on a mast.</p>
<p><img src="./images/antennaangle" title="fig:" alt="Example for an antenna installation" /> [fig:antennaangle]</p>
<p>[bitwidth=1.1em]<span>32</span><br /><br /><br /><br /><br /><br /><br /><br />&amp;<br /><br />&amp; &amp;<br /><br /></p>
<p>[fig:a1structure]</p>
<h4 id="encoding-example">Encoding example</h4>
<p>The following example illustrates the decoding of the input bit stream.<br />E4A2E4E263A2B54214A2B28E09AE02C36089219123696993EF9E1DF9D8647F18<br />496DC7340006E61B4030747CF7F849A84048143577861E6800000000000005780200<br />00000000000023000000000000000000000000000000</p>
<ul>
<li><p><code>Anonymous ID</code><br />Encoded Byte Array = 0xE4A2E4E263A2B54214A2B28E09AE02C36089219123696993EF9E1DF9D8647F18</p></li>
<li><p><code>Timestamp:</code> Wed Jan 14 12:06:28 CET 2009, in microseconds: 1231931188452123<br />Encoded Byte Array = 0x496DC7340006E61B</p></li>
<li><p><code>Latitude:</code> 16,45503187<br />Encoded Byte Array = 0x4030747CF7F849A8</p></li>
<li><p><code>Longitude:</code> 48,15788168<br />Encoded Byte Array = 0x4048143577861E68</p></li>
<li><p><code>Radius:</code> 1400<br />Encoded Byte Array = 0x0000000000000578</p></li>
<li><p><code>Input source:</code> Metawin<br />Encoded Byte Array = 0x02</p></li>
<li><p><code>Reserved:</code> 0<br />Encoded Byte Array = 0x000000</p></li>
<li><p><code>Reserved:</code> 0<br />Encoded Byte Array = 0x00000000</p></li>
<li><p><code>Event type:</code> Emergency Call<br />Encoded Byte Array = 0x23</p></li>
<li><p><code>Reserved:</code> 0<br />Encoded Byte Array = 0x00</p></li>
<li><p><code>Reserved:</code> 0<br />Encoded Byte Array = 0x0000</p></li>
<li><p><code>Angle:</code> 0<br />Encoded Byte Array = 0x0000000000000000</p></li>
<li><p><code>Speed:</code> 0<br />Encoded Byte Array = 0x0000000</p></li>
</ul>
<h3 id="subsec:events">Events</h3>
<p>In this subsection, we describe how everyday users activities are visible in the A1 data stream. The events detected by the monitoring units from each terminal depends on the type of terminal. While it is not feasible to cover all events (complete list of events is shown in Tab. [tab:eventtype]), we only describe the ones (mobility related) used in our system.</p>
<h4 id="calls">Calls</h4>
<p>When a terminal establishes a call with another subscriber a Mobile Originated Call event is created. The receiving terminal will create a Mobile Terminated Call event. Whenever a call is ended (e.g. one subscriber hangs up)an A Disconnect event is created. However in our research of the data stream, there was no evidence of an A Disconnect event.</p>
<ul>
<li><p>MOBILE TERMINATED CALL (0x1D): terminal receives a call</p></li>
<li><p>MOBILE ORIGINATED CALL (0x22): terminal originates a call</p></li>
<li><p>A DISCONNECT (0x18): The call is closed</p></li>
</ul>
<h4 id="location-area-update">Location Area Update</h4>
<p>Devices are most of the time in “idle” mode where they are switched on but are not involved in any voice/data communication. In this state the device must still be reachable by the network. Thus, when a terminal changes to a cell in a different location area, it sends a Location Area Update message to the core network. This message appears in the data stream as:</p>
<ul>
<li><p>LOCATION UPDATE (0x1F), in case of 2G terminal</p></li>
<li><p>IUCS LOCATION UPDATE NORMAL (0x15), in case of 3G terminal</p></li>
</ul>
<p>If a devices do not change its Location Area for a specific time and the PLAU timer expires it sends a keep alive message to the core network.</p>
<ul>
<li><p>IUPS RA PERIODIC UPDATE (0x0C) and IUCS LOC UPD PERIODIC (0x17) in case of 3G terminal (for PS and CS domain respectively)</p></li>
<li><p>LOCATION UPDATE (0x1F) in case of 2G terminals</p></li>
</ul>
<p>Fig. [fig:latraversed] illustrates where a location area update (red cell) happens when a subscriber traverses different location areas on its way.</p>
<p><embed src="./images/laupdate.pdf" title="fig:" /> [fig:latraversed]</p>
<h4 id="handover-cell-update">Handover Cell Update</h4>
<p>When a call is established the terminal is said to be in active “connected” state (see [subsub:connected]). In this state, the network is informed about each change of cell, regardless of the LA to which the cell belongs. A limitation is that the A1 data stream is not able to capture cell changes for 3G terminals (these messages do not reach the core network, but terminate in the radio access network, i.e. they cannot be monitored by the systems). However cell changes for 2G terminals appear as:</p>
<ul>
<li><p>GB CELL CHANGE (0x02), in case of an ongoing data connection,</p></li>
<li><p>HANDOVER CELL UPDATE (0x20), in case of an ongoing call.</p></li>
</ul>
<p><span>|l|p<span>4cm</span>|p<span>8cm</span>|</span> <strong>HEX</strong> &amp; <strong> Event Name</strong> &amp; <strong>Event Description</strong><br />0x01 &amp; GB ATTACH &amp; GPRS terminal attaches to the PS<br />0x02 &amp; GB CELL UPD &amp; GPRS terminal changes cell<br />0x03 &amp; GB OTHERS &amp; GPRS terminal changes cell but message is unclassified<br />0x04 &amp; GB RA UPD &amp; GPRS terminal changes RA<br />0x05 &amp; IUCS PAGING &amp; UMTS terminal is paged in the CS<br />0x06 &amp; IUPS PAGING &amp; UMTS terminal is paged in the PS<br />0x07 &amp; IU OTHER TLLI &amp; UMTS terminal changes cell but message is unclassified<br />0x08 &amp; IU OTHER TMSI &amp; UMTS terminal changes cell but message is unclassified<br />0x09 &amp; IUPS ATTACH &amp; UMTS terminal attaches to the PS<br />0x0A &amp; IUPS DETACH &amp; UMTS terminal detaches from the PS<br />0x0B &amp; IUPS RA UPD &amp; UMTS terminal attached to the PS changes RA<br />0x0C &amp; IUPS COMB RA/LA UPD &amp; UMTS terminal attached to both CS and PS changes LA (and therefore RA)<br />0x0D &amp; IUPS COMB RA/LA UPD WITH IMSI ATTACH &amp; UMTS terminal attaches to the PS and thecurrent RA differs from the one stored in the SIM<br />0x0E &amp; IUPS RA PERIODIC UPD &amp; UMTS terminal does not change RA for longer than a timer<br />0x0F &amp; IUCS DETACH &amp; UMTS terminal detaches from the CS<br />0x10 &amp; IUCS SMS ORIGINATED &amp; UMTS terminal sends an SMS<br />0x11 &amp; IUCS SMS TERMINATED &amp; UMTS terminal receives SMS<br />0x12 &amp; IUCS SETUP &amp; UMTS terminal requests the establishment of a call<br />0x13 &amp; IUCS CONNECT ACK &amp; UMTS terminal establishes a call<br />0x14 &amp; IUCS DISCONNECT &amp; UMTS terminal disconnect a call<br />0x15 &amp; IUCS LOC UPD NORMAL &amp; UMTS terminal attached to the CS changes LA<br />0x16 &amp; IUCS LOC UPD PERIODIC &amp; UMTS terminal does not change LAfor longer than a timer<br />0x17 &amp; IUCS LOC UPD &amp; UMTS terminal attaches to the CS and theWITH IMSI ATTACH current LA differs from the one stored in the SIM<br />0x18 &amp; A DISCONNECT &amp; GSM terminal disconnect a call<br />0x19 &amp; A OTHER &amp; unclassified message on A<br />0x1A &amp; PAGING CS &amp; GSM or GPRS terminal is paged in the CS domain<br />0x1B &amp; DETACH &amp; GSM or GPRS terminal detaches from the network<br />0x1C &amp; SMS &amp; GSM terminal sends or receives an SMS<br />0x1D &amp; MOBILE TERMINATING CALL &amp; GSM terminal receives a call<br />0x1E &amp; CM REESTABLISHMENT &amp; NA<br />0x1F &amp; LOCATION UPDATE &amp; GSM or GPRS terminal changes LA or emits aperiodic RA/LA update or attaches to the network<br />0x20 &amp; HANDOVER CELL UPDATE &amp; GSM terminal in active state changes cell<br />0x21 &amp; SUPPLEMENTARY SERVICE &amp; GSM terminal request a supplementary service<br />0x22 &amp; MOBILE ORIGINATED CALL &amp; GSM terminal originates a call<br />0x23 &amp; EMERGENCY CALL &amp; GSM terminal establishes an emergency call<br />0x24 &amp; SETUP &amp; GSM terminal request the establishment of a call<br />0x25 &amp; CONNECT ACK &amp; GSM terminal establishes a call<br />0x28 &amp; CLOSURE &amp; NA<br />0x29 &amp; GB PS PAGING &amp; GPRS terminal is paged in the PS domain<br /> [tab:eventtype]</p>
<h2 id="opencoveragemap">OpenCoverageMap</h2>
<p>OpenCoverageMap was a project and master thesis done by a colleague of mine at the University of Applied Science Upper Austria. Dieter Schlosser <span class="citation">\cite{Schlosser2012}</span> goal was to create an open network coverage map for mobile networks. Instead of relying on measurements and coverage reports handed out by network operators he was using smartphones that were doing the measurements. This approach, where users a carrying out work, is know as crowd-sourcing <span class="citation">\cite{Surowiecki2004}</span>.</p>
<h3 id="purpose">Purpose</h3>
<p>In our project, we are using OpenCoverageMap data to evaluate our approaches. In order to measure the network, OpenCoverageMap captures events similar to the events captured by A1. The OpenCoverageMap application which is installed on the smartphone periodically records the position (using GPS), the phone state as well as the currently connected cell site. Tab. [tab:ocmrecord] shows an example of data that was recorded by the OpenCoverageMap application.</p>
<table>
<thead>
<tr class="header">
<th align="left"><strong>Timestamp</strong></th>
<th align="left"><strong>Id</strong></th>
<th align="left"><strong>Cell-Id</strong></th>
<th align="left"><strong>LAC</strong></th>
<th align="left"><strong>Latitude</strong></th>
<th align="left"><strong>Longitude</strong></th>
<th align="left"><strong>State</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1328693325</td>
<td align="left">57</td>
<td align="left">9884</td>
<td align="left">5502</td>
<td align="left">48.2443810477206</td>
<td align="left">14.2600039950952</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">1328693326</td>
<td align="left">57</td>
<td align="left">9884</td>
<td align="left">5502</td>
<td align="left">48.2443056521896</td>
<td align="left">14.2599996518319</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">1328693327</td>
<td align="left">57</td>
<td align="left">9884</td>
<td align="left">5502</td>
<td align="left">48.2442309368497</td>
<td align="left">14.2600018504158</td>
<td align="left">2</td>
</tr>
<tr class="even">
<td align="left">1328693328</td>
<td align="left">57</td>
<td align="left">9884</td>
<td align="left">5502</td>
<td align="left">48.2441566900106</td>
<td align="left">14.2600058762345</td>
<td align="left">2</td>
</tr>
<tr class="odd">
<td align="left">1328693329</td>
<td align="left">57</td>
<td align="left">9884</td>
<td align="left">5502</td>
<td align="left">48.2440827177131</td>
<td align="left">14.2600098594458</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<p>[tab:ocmrecord]</p>
<p>The GPS information allows us to evaluate a route estimated by our system with the actually traveled route (see  [sec:route-validation] for more information).</p>
<h3 id="data-structure">Data Structure</h3>
<p>OpenCoverageMap does not capture events, therefore, our systems needs to covert the OpenCoverageMap data stream to the same format as the A1 data steam. Call establishment and termination events are generated by comparing the timestamps of each record. OpenCoverageMap logs the state of the MS every second. By iterating over the records and comparing the current state with the previous one, it is possible to extract call establishment and termination events. To generate handover events, an iteration over all records is done, each record compares the cell id and lac with the previous one. If both are similar no event is generated. However, if they are different a handover event is generated. After the conversion is done the OpenCoverageMap event stream looks the same as the A1 event stream.</p>
<h2 id="sec:voronoites">Voronoi Tessellation</h2>
<p>To generate trajectories for each mobile subscriber their coarse location is needed. For this purpose,we first need an estimation of the coverage area of all cell sites. When a mobile subscriber is connected to a cell site we know that his current position must be withing the coverage area of the cell site. A fast approximation of the coverage area can be done with Voronoi diagrams. As mentioned before Tettamanti2012 et al. <span class="citation">\cite{Tettamanti2012}</span> used Voronoi tessellation to estimate the coverage area.</p>
<p>Voronoi diagrams are widely used in computer science, e.g. pattern matching, space division, cluster analysis, collision detection, etc. as mentioned by Aurenhammer <span class="citation">\cite{Aurenhammer1991}</span>.</p>
<p><img src="./images/voronoi2" title="fig:" alt="Voronoi diagram of 16 random points in a 2D space" /> [fig:voronoi2]</p>
<h3 id="point-tessellation">Point Tessellation</h3>
<p>The following assumptions are based on <em>Voronoi diagrams–a survey of a fundamental geometric data structure</em> by Aurenhammer <span class="citation">\cite{Aurenhammer1991}</span> <em>Computational Geometry: Algorithms and Applications</em> by Makr de Berg <span class="citation">\cite{Berg2000}</span>.</p>
<p>Let <span class="LaTeX">$P=\{p_1,p_2,...,p_n\}$</span> be a set of <span class="LaTeX">$n$</span> distinct points, in our case the location of each cell site. The Voronoi diagram of <span class="LaTeX">$P$</span> is a subdivision of the plane into <span class="LaTeX">$n$</span> cells. The property that each Voronoi cell must fulfill is that a point <span class="LaTeX">$q$</span> lies in the cell respective to a site <span class="LaTeX">$p_i$</span> only if <span class="LaTeX">$dist\left(q,p_i\right) &lt; dist\left(q,p_j\right)$</span> for each <span class="LaTeX">$p_j \in P$</span> where <span class="LaTeX">$i \neq j$</span>. Each cell defines the coverage area for the n-th cell site. Moreover each cell is a (possibly unbounded) open convex polygon. Fig. [fig:voronoi2] illustrates a Voronoi diagram for 16 random points in a two dimensional space. It can be seen that the outer cells are not closed, they shape an open convex polygon. In Section [sec:boundaries] we show a method to produce closed polygons.</p>
<p><span class="LaTeX">$$dist(p,q)=\sqrt{\left(p_x-q_x\right)^2+\left(p_y-q_y\right)^2}$$</span></p>
<h3 id="sec:boundaries">Boundaries</h3>
<p>Voronoi diagrams are unbounded which means that the coordinates of vertices can be infinite. Unbounded polygons are undesired in a topology computation. If we would use unbounded polygons for coverage estimation, the area for this cell site would be infinite. A simple approach to eliminate this effect is to clip the Voronoi diagram with a rectangular bounding box. However, this approach is only satisfying if the cell site boundaries shape a rectangle. A better approach is to compute the convex hull over all sites and clip it with the Voronoi diagram.</p>
<h3 id="cell-tower-segmentation">Cell Tower Segmentation</h3>
<p>We mentioned before that a GSM network consists not only of omni directional antennas but also of sectored antennas. The coverage area of each sector is defined by the angle at which the antenna is mounted on the tower. If we would only consider the location of each cell sites, sectors with different angles would have the same Voronoi polygon and, therefore, the same coverage area. In order to get a better representation of the coverage area for each sector, we moved the location of each sector based on its angle <span class="LaTeX">$\phi$</span>. The definition of the movement can be found in Equation [eq:move]. The constant factor means a maximum movement of 3 meters in either direction.</p>
<p><span class="LaTeX">$$\label{eq:move}
	x=x+\frac{cos(\phi)}{50000},y=y+\frac{cos(\phi)}{50000}$$</span></p>
<h1 id="cha:concepts">Trajectory Generation Pipeline</h1>
<p>In this chapter, the pipeline to generate trajectories for mobile subscribers is introduced. The developed pipeline consists of a five-steps model, which is shown in Figure [fig:pipeline]. The concept to generate trajectories is the following: The input data is iteratively used to generate trajectories for each subscriber. The output is a trajectory which consists of the route, traveled by the subscriber as well as timestamps, which defines the point in time when the subscriber was located at this location. Given below each step of the pipeline is described in more detail to better understand how the system operates.</p>
<p><img src="./images/pipeline" title="fig:" alt="Developed trajectory generation pipeline. The trapezoids represent the single steps in the pipeline, the rounded rectangles illustrate the outputs of the particular steps" /> [fig:pipeline]</p>
<h2 id="input-data">Input Data</h2>
<p>This section focuses on input data that is consumed by the system. The gathering of input data is the first step in the developed pipeline. Moreover input data can be distinguished between four data types, which are used by the system: geographical data, socio-statistical data, mobile subscription data (A1 and OCM), road network data. The different data types are described in the succeeding sections.</p>
<h3 id="geographical-input-data">Geographical Input Data</h3>
<p>As mentioned before GSM does not expose an accurate location of the subscriber. In GSM, only the Cell-ID of the current connected cell is known. However, to calculate a route between the start and end of the call a more accurate location is needed. Because the coverage area of cell can be from as little as <span class="LaTeX">$500m^2$</span> up to <span class="LaTeX">$50km^2$</span>, boundaries need to be set in which subscribers can be located. The assumption is that the majority of subscribers will start or end their journey in an urban fabric whereas only a small fraction of subscribers will start or end their journey in open land. In the course of this project the geographic information is derived from data from the <em>CORINE</em><a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> project which was initiated by the European Commission in 1985. The main purpose of this project was to generate a geographic information system for the member states of the European Union. The <em>CORINE</em> land cover (CLC) project is one essential part of the <em>CORINE</em> projects which aim to develop a land cover information system for twelve member states of the European Union (Effective 2006). The <em>CORINE</em> land cover project distinguishes between five main categories and in total 44 land cover classes. Out of the five only two categories are applicable for the purpose of defining boundaries where a subscriber can be located: <em>artificial surfaces</em> and <em>agricultural areas</em>. The three remaining categories –<em>forest and semi-natural areas</em>, <em>wetlands</em> and <em>water bodies</em>– can be considered as areas where subscribers are not starting or ending their calls. The <em>CORINE</em> land cover data for Austria can be obtained from the following service<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. The land cover data is provided in two different data types, first as a raster image with a grid size of 100 meters and second as a Shapefile..Figure [fig:clc<sub>a</sub>ustria] illustrates the land cover map<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> of Austria. The red spots within the image represents urban fabric areas whereas green denotes to forest and semi-natural areas.</p>
<p><img src="./images/clc_austria.png" title="fig:" alt="Corine land cover map of Austria" /> [fig:clc<sub>a</sub>ustria]</p>
<h3 id="socio-statistical-input-data">Socio-statistical Input Data</h3>
<p>The second type of input data used in the generation pipeline are population density maps. Population density maps belong to the class of socio-statistical and provide information about the distribution of population in a geographical area. Gallego et al. <span class="citation">\cite{Gallego2010,Gallego2011}</span> describe several disaggregation methods which can be used to generate a population density map of the European Union. Their approach uses information from the <em>CORINE</em> land cover project to derive a population density grid with 100 meters grid spacing. The population density grid is used in the developed system to narrow the location of a user within the current connected cell. This works in conjunction with <em>CORINE</em> land cover. A more detailed description of the described process will be presented later. The population density grid can be obtained freely from the European Environment Agency (EEA) <a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a>. Similar to the <em>CORINE</em> land cover data the population density grid is available in two data types.</p>
<h3 id="a1-dataset">A1 Dataset</h3>
<p>The mobile subscription data which is provided by A1 is used to generate trajectories for subscribers. To generate trajectories, the developed system is fed with an event stream for a special user. This event stream contains all events which have been captured during one day. As we mentioned before in Section [sec:anonymous] the anonymous user id changes at least every 24 hours. Therefore it is only possible to extract trajectories for one day per subscriber. Each event stream can contain zero, one or <span class="LaTeX">$n$</span> calls. Every call in the event stream represents a trajectory.</p>
<h3 id="ocm-dataset">OCM Dataset</h3>
<p>In order to validate our approach we need not only an event stream but also the path traveled by the subscriber. Therefore, the developed system uses an event stream provided by the OpenCoverageMap project. After a conversion to the A1 event format, this event stream can be provided to the developed system. In addition to the A1 event stream, it contains the traveled path which was recorded via GPS on a mobile phone. The GPS tracks allow the system to validate the route finding process as well as the timing estimation. The comparison between the estimated trajectory and the actually traveled route helps to validate the routing. By calculating the speed from the GPS the system can validate how well the timing estimation has been done. More details to the validation process will be provided in Section [sec:routevalidation],[sec:timing-estimation].</p>
<h3 id="road-network">Road Network</h3>
<p>The last input data for the developed system is a representation of the road network. Individuals walk or drive on predefined paths: streets, paths, etc. To generate trajectories, the system needs to have a representation of the road network to assign the path of subscribers on the road network. A freely available and open-source road network is provided by the OpenStreetMap<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> project. The aim of OpenStreetMap is to provide a world wide map which can be used without any royalties. Contributers all over the world are feeding OpenStreetMap with new data. Therefore, OpenStreetMap is very accurate for locations where the number of contributers is high. Figure [fig:map<sub>l</sub>inz] illustrates a map<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> of Linz, Austria generated by OpenStreetMap. It can be seen that OpenStreetMap provides a large variety of data (e.g. streets, paths, buildings, POI, etc.).</p>
<p>The developed system utilizes the road network from OpenStreetMap to estimate a start and end position of the trajectory as well for route generation. Additionally OpenStreetMap is used to validate the timing estimation for subscribers where no GPS path is available which is the case for A1 subscribers.</p>
<p><img src="./images/map_linz" title="fig:" alt="OpenStreetMap map of Linz, Austria" /> [fig:map<sub>l</sub>inz]</p>
<h3 id="voronoi-coverage">Voronoi Coverage</h3>
<p>The developed system needs a representation of the coverage area for each cell site. As described before in Section [sec:voronoites] Voronoi tessellation can be used to calculate an approximate coverage area. However, as Voronoi tessellation only takes the location of the cell site and not the physical characteristics (shadowing, antenna gain, reflections, path loss,etc. ) the approximation is not very accurate. To calculate the coverage area –the Voronoi polygon – for each cell site, the system is using the location and the angle of the antenna as input data for the calculation. The angle is needed to separate sector antennas which are mounted on the same cell tower.</p>
<h3 id="coverage-planning">Coverage Planning</h3>
<p>Because the developed system is based on handover point estimation, an accurate approximation of the coverage area is needed. Besides Voronoi tessellation, a network planning tool is used. The network planning tool not only takes the location of the cell site but also the physical characteristics into account. The physical characteristics are the following:</p>
<ul>
<li><p>Digital Elevation Model</p></li>
<li><p>Transmit Power</p></li>
<li><p>Path Loss</p></li>
<li><p>Shadowing</p></li>
<li><p>Line Of Sight</p></li>
<li><p>Multipath propagation</p></li>
</ul>
<p>By using the physical characteristics, the calculated coverage area is more accurate than the simple approximation done with Voronoi tessellation. Since this system has no access to the physical properties of the operator, it is using freely available information. This information consists of a Digital Elevation Model of the research area and the transmit power of cell sites.</p>
<h4 id="digital-elevation-model">Digital Elevation Model</h4>
<p>The network planning tool is using a Digital Elevation Model to calculate properties such as path loss, shadowing and line of sight. This properties are important for the coverage prediction. The European Environment Agency<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a> provides a Digital Elevation Model of Europe. A Digital Elevation Model is aligned in a grid and for each cell of the grid the altitude above sea level is known. The EEA Digital Elevation Model consists of a raster with 25 meters grid spacing. The coverage prediction is limited by the resolution of the underlaying Digital Elevation Model. Therefore by using a better model the accuracy of the prediction can be increased.</p>
<h4 id="transmit-power">Transmit Power</h4>
<p>The transmit power defines the power level of the transmitter in the antenna. An increase in transmit power means an increase in coverage as the path loss effect will be minimized. Because the network operator has not provided any information about the transmit power of its BTS the system is using an alternative data source. In Austria the Forum Mobilkommunikation provides a service called <em>Senderkataster</em><a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a>. The Senderkataster allows to view all broadcast and mobile communication transmitters on a map. In addition to the location it, also depicts the transmitting power. The Senderkataster defines the following four categories for transmit power:</p>
<ul>
<li><p>Category 1: &lt; 15 Watt</p></li>
<li><p>Category 2: 15 - 50 Watt</p></li>
<li><p>Category 3: 50 - 100 Watt</p></li>
<li><p>Category 4: &gt; 100 Watt</p></li>
</ul>
<p>By querying the Senderkataster with the research area, the system can get the transmitting power. However, the Senderkataster is a voluntary project and relies on the data provided mobile network operators. This has the disadvantage that every cell site of a network operator is listed in the Senderkataster.</p>
<h5 id="data-extraction">Data Extraction</h5>
<p>The Senderkataster service can be queried with simple HTTP requests (see Listing [lst:senderbbox]). The services takes a bounding box of the research area and returns all transmitters withing the bounding box. The bounding box is defined by the four parameters –left, right, bottom, top – <em>EXL</em>, <em>EXR</em>, <em>EXB</em> and <em>EXT</em>. The coordinates are projected in the WIGeoEU projection (EPSG 7397) <a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a>. After the request was sent to the service, the service delivers all the transmitters in the following format <code>301377|314876|2057165</code>. The first parameter is the internal ID of the transmitter, second the X coordinate, and lastly the Y coordinate. The ID can then be used to retrieve additional informations such as the transmitting power, the transmitter type and if it is mounted on a house or a tower.</p>
<p>To retrieve more information about the transmitter a request (see Listing [lst:transmitterinfo]) to the service with the ID is made. The response to the request is the following: <code>mobilfunk|301377|GSM/UMTS|d|41,48|1</code> . The first parameter describes the transmitter, it can either be a mobile radio network or a broadcast transmitter used for terrestrial radio and television . Second is the ID, the third one depicts the used technology (GSM, GPRS, UMTL, LTE), the fourth indicates if the transmitter is mounted on the roof (d) or a tower (e), followed by the transmit power in Watt and the last parameter shows if other transmitter are using the same tower.</p>
<pre><code>http://www.senderkataster.at/functions/getPoints.php5
?EXL=312790.83396198
&amp;EXR=315119.16603802
&amp;EXB=2056054.8754715
&amp;EXT=2057801.1245285</code></pre>
<pre><code>http://www.senderkataster.at/functions/getInfos.php5
?TYPE=mobilfunk
&amp;ID=301377</code></pre>
<h4 id="cell-site-and-transmitter-position">Cell Site and Transmitter Position</h4>
<p>The latitude and longitude coordinates of the A1 data specify the location of the cell tower. On each cell tower there can be one or more transmitters mounted. The network planning tool is using two databases, one for the cell site (tower position) and the second one for transmitters. Each transmitter is assigned to one cell site whereas a cell site can be connected to one or more transmitters.</p>
<p>By querying the A1 data set and only storing unique tuples of latitude and longitude, the system can derive all cell site locations. To get the transmitters for each cell site, the A1 data set is queried for each unique location tuple. A basic transmitter consists of a location, Cell-ID, LAC, power, height and angle. The location is a direct relation to the cell site. The power indicates the transmit power. As there is not information about the installment height of the transmitter it was set to be <span class="LaTeX">$20$</span> meters for all transmitters. A higher transmitter height might increase the coverage area for areas shadowed by hills or buildings. The angle defines the mounting angle and indicates in which direction the transmitter is beaming.</p>
<h4 id="best-server-plot">Best Server Plot</h4>
<p>All the above mentioned data is fed into the network planning tool to calculate the best server plot that is used as a coverage prediction. A best server plot calculates for each transmitter its path loss effect. The path loss specifies the reduction of power density of an electromagnetic wave as it propagates through space. To calculate the path loss for each transmitter the COST-Hata model is used which extends the urban Okumura-Hata model . The main equations of the COST-Hata model are depicted in Equation  [eq:costhata].</p>
<p>[eq:costhata]</p>
<p>[eq:pathloss] L = 46.3 + 33.9f - 13.82 h<sub>B</sub> - a(h<sub>R</sub>) + [44.9 - 6.55 h<sub>B</sub>] d + C</p>
<p>[eq:antennacor] a(h<sub>R</sub>)=(1.1f-0.7)h<sub>R</sub>-(1.56f-0.8)</p>
<p>C =</p>
<p>0 dB<br />3 dB</p>
<p><span class="LaTeX">$L$</span> = Median path loss. Unit: Decibel (dB)</p>
<p><span class="LaTeX">$f$</span> = Frequency of Transmission. Unit: Megahertz (MHz)</p>
<p><span class="LaTeX">$hB$</span> = Base Station Antenna effective height. Unit: Meter (m)</p>
<p><span class="LaTeX">$d$</span> = Link distance. Unit: Kilometer (km)</p>
<p><span class="LaTeX">$hR$</span> = Mobile Station Antenna effective height. Unit: Meter (m)</p>
<p><span class="LaTeX">$a(hR)$</span> = Mobile station Antenna height correction factor as described in the Hata Model for Urban Areas..</p>
<p>The path loss was calculated for various distance in the interval [0..5000] meters. Therefore, the path loss effect for each transmitter in the calculation area is known. The coverage prediction simply takes the path loss effect and assigns the best server as the transmitter with the least path loss.</p>
<p>[b]<span>0.45</span> <img src="signallevelmapsmall" title="fig:" alt="Signal Level Plot" /> [fig:signallevel]</p>
<p> </p>
<p>[b]<span>0.45</span> <img src="coveragemapsmall" title="fig:" alt="Coverage Prediction" /> [fig:coveragepred]</p>
<p>[b] <img src="tikz/signallevelbar" title="fig:" /> [fig:signallevelbar]</p>
<p>[fig:cellarea]</p>
<p>Figure [fig:cellarea] shows two plots different path loss plots for Hagenberg, Austria. The first one Figure [fig:signallevel] depicts the attenuation for each transmitter in the area. The red area indicates a small attenuation whereas yellow indicates a high attenuation. The colorbar in Figure [fig:signallevelbar] indicates the signal strength (dBm) for the above signal level plot.</p>
<p>From theses attenuation values, a best server plot – coverage prediction – for each transmitter can be derived as shown in Figure [fig:coveragepred]. It can be seen that there is an overlapping area between neighboring transmitters. The system is using the predicted coverage area for start and end point estimation and timing purposes.</p>
<h2 id="call-detection">Call Detection</h2>
<p>This section describes the process of filtering calls within each event stream. The two used event streams – A1 and OCM – are using different events to signalize call establishment and termination. After this process, the system can generate a trajectory for each call found in the event stream.</p>
<h3 id="a1-calls">A1 Calls</h3>
<p>To signalize the establishment of a call in the A1 event stream either a <em>Mobile Originated Call</em> or a <em>Mobile Terminated Call</em> event is issued. The first event is used when a mobile station initiates a call with another subscriber. The mobile station of the other subscriber will issue the second event once the call has been established with the first subscriber.</p>
<p>When either of the involved subscribers terminates the call, a <em>A Disconnect</em> event shall be issued by both subscribers. However, during an investigation of the event stream there was no occurrence of this event. Therefore the developed system is using an approach by which it investigates events that have been issued after a call establishment. If the system recognizes either one of the following events: <em>SMS</em>, <em>Mobile Originated Call</em>, <em>Mobile Terminated Call</em>, <em>Location Area Update</em> or <em>IMSI detach</em> it generates a call termination event before.</p>
<h3 id="ocm-calls">OCM Calls</h3>
<p>Rather than capturing events in the network, the OpenCoverageMap project periodically stores the state of the mobile phone. The state can either be <em>idle</em> or <em>connected</em>. In order to detect a call, the system has to find changes in the state. If a state change is detected the corresponding event is issued. A call establishment is detected when the state changes from <em>idle</em> to <em>connected</em>. In contrast to the call establishment, the call termination is detected when the state changes from <em>connected</em> to <em>idle</em>.</p>
<p>The detection of call terminations is more accurate for OpenCoverageMap than for A1 where no information is available if a call is still ongoing. Because OpenCoverageMap periodically stores the state of the mobile phone whereas in order to detect a call termination for A1 events the system has to recognize a follow-up event.</p>
<h2 id="route-calculation">Route calculation</h2>
<p>The following section presents the process of calculation a route for a mobile subscriber. In genera,l each call is used to calculate one route which is later transfered to a trajectory. The process consists of several steps which will be described in the succeeding sections.</p>
<h3 id="start-and-end-position-estimation">Start and End Position Estimation</h3>
<p>The first step in the route calculation process is to estimate the subscribers start and end position. As mentioned before GSM only exposes the Cell-ID which only defines a boundary in which the subscriber is located. To narrow this boundaries the system is using geographical input (<em>CORNINE</em> land cover) and socio-statistical maps (population density maps).</p>
<p>By using <em>CORNINE</em> land cover data the system can define areas where it is unlikely that a subscriber will start or end his journey. This step can be parameterized by giving each of the CLC classes a percentage factor. The percentage defines how likely it is that a subscriber starts or ends a call in this class.</p>
<p>Our second second assumption is that subscribers will more likely start or end their call in a higher populated area within the cell boundaries. More subscribers are located in higher populated areas than in less populated ones. Therefore the system is using population density maps in order to better estimate the start or end position. Figure [fig:pop<sub>v</sub>ienna] shows an example for a population density map for Vienna, Austria. In this example it can be seen that the density is higher in the inner districts than in the outer ones.</p>
<p><img src="./images/pop_vienna" title="fig:" alt="Population density map of Vienna, Austria. The population density is higher in darker (purple) than in brigher areas" /> [fig:pop<sub>v</sub>ienna]</p>
<h4 id="corine-land-cover-clipping">Corine Land Cover Clipping</h4>
<p>By clipping and therefore removing unwanted areas the system can narrows the boundaries in which a subscriber is located. To clip the coverage area of a cell the system loads the <em>Corine</em> land cover map for the particular area. The next step is to clip the cell coverage area with useful <em>CORINE</em> land cover categories such as <em>artificial surfaces</em> and <em>agricultural areas</em>. This technique known as polygon clipping removes unwanted area –<em>forest and semi-natural areas</em>, <em>wetlands</em> and <em>water bodies</em> – from the cell.</p>
<h4 id="population-density-estimation">Population Density Estimation</h4>
<p>After removing unwanted areas within the cell coverage area the next step is to estimate the subscribers position. This step is the same for start and end positions. By using the population density information of the coverage area the system dices a position based on the population density. Therefore more subscribers will be located in higher populated areas.</p>
<h5 id="population-density-clipping">Population Density Clipping</h5>
<p>The first step is to load the population density map for the coverage area. A random number generator with a defined probability density function will created. The probability density function is derived from the population density map. When the system loads the population density map for the coverage area it will get <span class="LaTeX">$n$</span> polygons with <span class="LaTeX">$n$</span> different population densities. More generally speaking each area with a unique population density is represented by a polygon. Afterwards the random number generator is used to dice a area of interest. By using the population density as function for the random number generator areas with a hight population density will be picked more often than less populated areas. Once the system picked a polygon based on the random number generator it clips this polygon with the coverage area. This process narrows the boundaries of the subscribers location. Following the subscribers location will be set by dicing a location within the remaining coverage area. Figure [fig:population] illustrates an example for different population densities within the boundaries of one cell. We can see that total population is <span class="LaTeX">$315$</span>. We calculate a <em>pdf</em> for all three population cells based on the ratio of the population and the total population. The calculated <em>pdf</em> will be used to estimate the user’s start and end position. As an example the probability that the starting point is within the polygon with Population 240 is given by 240/315. Within the polygon “Population 240” the starting point is selected based on a uniform distribution.</p>
<p>[scale=0.70]</p>
<p>[ xlabel=<span class="LaTeX">$x$</span> in meter, ylabel=<span class="LaTeX">$y$</span> in meter, legend pos=outer north east]</p>
<p>+[mark=none,draw=black, very thick,dashed] coordinates <span>(0,0) (300,0) (400,300) (300,500) (0,300)</span> – cycle;</p>
<p>+[mark=none,pattern=crosshatch,area legend,draw=black] coordinates <span>(0,0) (300,0) (300,300) (0,300)</span> – cycle;</p>
<p>+[mark=none,pattern=grid,area legend,draw=black] coordinates <span>(0,300) (300,300) (300,500) (0,300) </span> – cycle;</p>
<p>+[mark=none,pattern=crosshatch dots,area legend,draw=black] coordinates <span>(300,0) (300,500) (400,300) </span>– cycle;</p>
<p>[fig:population]</p>
<h5 id="random-point-in-coverage-area">Random Point in Coverage Area</h5>
<p>Dicing a random location into a rectangular shape is an easy task, however the shape of the remaining coverage area will unlikely be a rectangular. A simple approach is using the bounding box of the coverage area polygon and dicing coordinate pairs for the bounding box as long as one coordinate pair lays within the coverage polygon. This simple approach has one major disadvantage because it is unpredictable. There is no estimation for how long it would take that one coordinate pair is contained in the coverage polygon.</p>
<p>A more sophisticated approach is to triangulate the coverage polygon into triangles. Triangulation of convex monotype polygons can be done with algorithms by A. Fournier and D.Y. Montuno <span class="citation">\cite{Fournier1984}</span> or Godfried Toussaint <span class="citation">\cite{Toussaint1984}</span>. The developed system uses the GDAL project <span class="citation">\cite{GDAL}</span> which provides an implementation of polygon triangulation for many platforms and programming languages. Figure [fig:triangulation] depicts the triangulation of a polygon into triangles. The polygon is split into 3 triangles by applying Fourniers algorithm.</p>
<p>[scale=0.70]</p>
<p>[ xlabel=<span class="LaTeX">$x$</span> in meter, ylabel=<span class="LaTeX">$y$</span> in meter, legend pos=outer north east]</p>
<p>+[mark=none,draw=black, very thick,dashed] coordinates <span>(0,200) (200,450) (600,350)(700,0)(200,0) </span> – cycle; +[mark=none,pattern=crosshatch,area legend,draw=black] coordinates <span>(0,200) (200,450) (600,350) </span> – cycle; +[mark=none,pattern=grid,area legend,draw=black] coordinates <span>(0,200) (600,350)(200,0) </span> – cycle; +[mark=none,pattern=crosshatch dots,area legend,draw=black] coordinates <span>(200,0) (600,350)(700,0) </span> – cycle;</p>
<p>[fig:triangulation]</p>
<p>As already discussed before the developed system needs to uniformly distribute subscribers location with the polygon. A <em>pdf</em> will be created by using the area of each triangle as input. A random number generator will use this <em>pdf</em> and randomly assign the triangle in which the subscribers location shall be diced.</p>
<p>In Figure [fig:comprandom] two different approaches for random triangle point picking. The first one is picking a point within the boundaries of the triangle whereas the second one is picking a point in a quadrilateral which consist of the triangle and its mirroring. To pick a point in a triangle the first approach is using Equation [eq:randtriangle] where <span class="LaTeX">$a_1$</span> and <span class="LaTeX">$a_2$</span> are uniform random numbers in the interval <span class="LaTeX">$ \left[0,1 \right] $</span>, <span class="LaTeX">$v_1$</span> and <span class="LaTeX">$v_2$</span> are two vertices’s of the triangle. As depicted in Figure [fig:randtriangle] this approach does not create uniform distributed points within the triangle. The second approach is different from the first one as it does not pick points within the triangle but rather in a quadrilateral made of the original triangle and its mirroring. Figure [fig:quadrilateral] shows that this approach creates uniform distributed points. However the points are created in a quadrilateral instead of a triangle this can be overcome by removing points outside of the triangle.</p>
<p><span class="LaTeX">$$p=a_1*v_1+(1-a_1)*a_2*v_2
	\label{eq:randtriangle}$$</span></p>
<p><span class="LaTeX">$$p=a_1*v_1+a_2*v_2
	\label{eq:randquad}$$</span></p>
<p>[b]<span>0.45</span> <img src="randompointpolygon" title="fig:" alt="Random Point in Triangle" /> [fig:randtriangle]</p>
<p> </p>
<p>[b]<span>0.45</span> <img src="randompointquadliteral" title="fig:" alt="Random Point in Quadrilateral" /> [fig:quadrilateral]</p>
<p>[fig:comprandom]</p>
<h3 id="routing">Routing</h3>
<p>The developed system is using the OpenStreetMap road network and the OSM2PO<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> route engine. After estimating a random start and end position of the subscriber a route between these two points will be calculated with OSM2PO.</p>
<h4 id="osm2po">OSM2PO</h4>
<p>OSM2PO is a project developer by Carsten Moeller which allows routing on the freely available OpenStreetMap road network. On the first start OSM2PO is generating a graph network out of the road network. The graph network is used internally of OSM2PO and allows a faster route calculation. OSM2PO can calculate the fastest route by using speed limit information or the shortest route with minimum distance.</p>
<h4 id="route-generation">Route Generation</h4>
<p>The system first estimates a start and position for the subscriber and calculates the fastest route between these two points. The calculated route contains the geometry of the route, the used roads and the speed limit of each road segment. This information will later be used by the system to validate the route.</p>
<h2 id="sec:routevalidation">Route Validation</h2>
<p>Route validation is necessary to use the best estimation of the traveled route. For each subscriber there will be more than one route generated based on a configuration parameter. The developed system uses two different types of route validation, the first evaluates the route geometry and the second the timing. Each of the validations can be treated separately or in conjunction. By combining the results a better validation can be achieved.</p>
<h3 id="geometry-validation">Geometry Validation</h3>
<p>Geometry validation is used to evaluate the estimated route with the subscribers handover sequence. In addition when using events from the OpenCoverageMap the system can validate the estimated route with the actual route based on the GPS information.</p>
<h4 id="squared-sum">Squared Sum</h4>
<p>The first validation the system is doing for each route is to calculate the squared sum between the cell sites of the handover sequence and the calculated route. To compare different routes Equation [eq:sumsquaremine] was used. This is the same metric Tettamanti et al.<span class="citation">\cite{Tettamanti2010}</span> used for their system. For each calculated route <span class="LaTeX">$j$</span> the squared sum of all minimum distances <span class="LaTeX">$d_{i,j}$</span> between the route and the cell site was calculated. Figure [fig:rms] illustrates the minimum distance between the centroid of a cell site and a calculated route.</p>
<p><span class="LaTeX">$$\label{eq:sumsquaremine}
	D_j=\sum_{i=1}^{m} d_{i,j}^{2}$$</span></p>
<p><img src="./images/rms" title="fig:" alt="Minimum distance between centroid of cell site and route" /> [fig:rms]</p>
<h4 id="hausdorff-distance">Hausdorff Distance</h4>
<p>If the system is using events from the OpenCoverageMap project the actual route traveled by the subscriber is known by storing GPS information. This allows the system to validate the calculated routes with the actual route. The developed system is using the Hausdorff distance named after Felix Hausdorff <span class="citation">\cite{Rockafellar1998}</span>. The Hausdorff distance measures how far two subsets of a metric space are from each other, it is the maximum of all the distances from a point in one set to the closest point in the other set. In our system the two sets consists of the calculated and the actual route. Figure [fig:Hausdorff<sub>d</sub>istance<sub>s</sub>ample] depicts the Hausdorff<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a> distance between to paths <span class="LaTeX">$X$</span> and <span class="LaTeX">$Y$</span>. Therefore the system is using the Hausdorff distance to measure the similarity between the calculated and the actual route.</p>
<p><img src="./images/Hausdorff_distance_sample" title="fig:" alt="Hausdorff distance between two sets" /> [fig:Hausdorff<sub>d</sub>istance<sub>s</sub>ample]</p>
<h3 id="timing-validation">Timing Validation</h3>
<p>Besides geometry validation the system is taking the time it needs to actually drive the route into account. When the system generates a trajectory for a subscriber it knows the time when the subscriber initiated and terminated the call. This information is used to extract the journey time. A ratio <span class="LaTeX">$r_t$</span> between the actual journey time <span class="LaTeX">$t_{actual}$</span> and the time it takes to travel the estimated route <span class="LaTeX">$t_{route}$</span> is calculated (see Equation [eq:timeratio]). The ratio gives information if the estimated router is either to fast or to slow. A to fast route can indicate that the route is either too long or that the subscriber was stuck in traffic congestions. On the other hand a slower estimated route can indicate that either the wrong route was chosen or that the subscriber was going faster than the speed limit. Therefore a conjunction of all validations is needed to choose the best approximated route.</p>
<p><span class="LaTeX">$$r_{t}=\frac{t{actual}}{t{route}}
	\label{eq:timeratio}$$</span></p>
<h2 id="sec:timing-estimation">Timing estimation</h2>
<p>Whenever a subscriber is in an active call and moves from one cell to another one a handover event is issued. This event exposes a coarse location and a time stamp. By using this information the system can derive the velocity of the subscriber. The velocity of a subscriber is an important figure for mobility simulation. Because the velocity together with the estimated route describes the mobility of the subscriber. However as we the system only knows the cell in which the handover event originated – cell to which handover was made – an estimation of the actual handover point is needed. A more precise estimation of this handover point results in a better velocity approximation.</p>
<h3 id="handover-point-estimation">Handover Point Estimation</h3>
<p>To estimate handover points the system is using two successive handover events. These two events consists of a time stamp, cell-Id and LAC. From the cell-Id and LAC the system can obtain the coverage area of the two cells. During research of the A1 and OCM data we discovered that there are two types of handover. The successive handover are either connected or apart. Connected handover are handover which coverage areas touches or overlaps each other. An apart handover is a handover where the coverage areas are not touching or overlapping.</p>
<p>[b]<span>0.4</span> <img src="handover_together" title="fig:" /> [fig:handovertogether]</p>
<p> </p>
<p>[b]<span>0.55</span> <img src="handover_apart" title="fig:" /> [fig:handoverapart]</p>
<p>[fig:handovertypes]</p>
<p>The difference of the two handover types is illustrated in Figure [fig:handovertypes]. For connected handover it is obvious where the handover happened. For this purpose the system is taking the touching or overlapping parts of the coverage areas and the intersection with the estimated route. In contrast for apart handover it is not clear where the handover happened. It could either happen at the boundaries of the first cell or the second cell or in between those. A simplification is to use the middle point between the two cells.</p>
<h3 id="velocity">Velocity</h3>
<p>After the handover points have been estimated the next step is to enrich this information with the timestamps when the handover occurred. As mentioned before in Section [subsec:events] each event contains a precise timestamp when the event was captured by the underlying system. This information together with an estimated route and handover point allows to derive the velocity of the driver. The system knows the time difference between two handover events as well as the distance traveled. The traveled distance is the distance between two successive handover points. By cutting the whole route with the two handover points the system can obtain the route between the two handover points and therefore the actual distance between those. The velocity can then be calculated by dividing the distance <span class="LaTeX">$s$</span> between the handover over the time difference <span class="LaTeX">$t$</span> between the handover <span class="LaTeX">$v=\frac{s}{t}$</span>. The calculated velocity represents the average distance between the handover.</p>
<h1 id="cha:implementation">Implementation</h1>
<p>The following chapter will present the actually implemented system. The implementation is based on Chapter [cha:concepts] where the concepts for the system have been presented. Through out this chapter all parts of the system and their responsibilities will be explained.</p>
<h2 id="system-overview">System Overview</h2>
<p>The developer system consists of a set of individual systems. This systems can be grouped in three groups. The first is responsible for storing information such as: mobile subscription data, population and land use information, road network and cell coverage areas. The second is a data abstraction layer which is used to aggregate the data and present to interested systems via an API. The last group is responsible for processing and generating trajectories. It is using the other systems via the API provided by the data abstraction layer. A brief overview of the implemented system is illustrated in Figure [fig:systemoverview].</p>
<p><img src="./images/systemoverview" title="fig:" alt="System overview of the implemented system" /> [fig:systemoverview]</p>
<p>It depicts the data store which consists of two different databases, the first is responsible for storing geographic information and the second for storing subscription information from A1 and OCM.</p>
<h3 id="data-store">Data Store</h3>
<p>The data store is responsible for storing data, this data either is either geographic information or subscription data. For geographic data the system is using PostgreSQL with the PostGIS extension. PostGIS extends PostgreSQL with support for spatial data structures and topological queries <span class="citation">\cite{Obe2011}</span>. Therefore, it allows the system to store the OpenStreetMap road network, population and land use information, the coverage area and the location of each cell site. PostGIS allows the use of advanced spatial queries as intersections and clipping which is later needed by the system.</p>
<p>Subscription data is stored in a separate MySQL database. It is storing events captured by the A1 system and the OpenCoverageMap project. The database consists of two tables, one for A1 and the second one for OpenCoverageMap.</p>
<h3 id="data-abstraction-api">Data Abstraction API</h3>
<p>We first started to develop a system with direct access to the database via the JDBC driver for PostgresSQL<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a> and MySQL<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a>. But this approach was not sufficient as we experienced a slow data access rate with larger queries. Therefore, we decided to build an abstraction layer which encapsulates the access of the database form the system. The abstraction layer is built with Node.js – a JavaScript framework – and it provides a HTTP API. More details will be provided in Section [sec:architecture].</p>
<h3 id="trajectory-generation">Trajectory Generation</h3>
<p>The trajectory generation group consists of two systems. First the trajectory service which is generating trajectories for subscribers and second the routing engine which is responsible for calculating routes between a start and end point.</p>
<h2 id="sec:architecture">Architecture</h2>
<p>After a brief overview has been given in the previous section, here the underlying system will be explained in more detail. It will also cover the process of importing the needed data into the database and how this data can be retrieved from the database. Moreover the used data and the communication between the subsystems will be described.</p>
<h3 id="postgresql-database">PostgreSQL Database</h3>
<p>To store geographic information PostgreSQL together with the PostGIS extension is used. PostGIS extends PostgreSQL in a way that it follows the Simple Features for SQL specification from the Open Geospatial Consortium. The Simple Features are defined in ISO 19125 <span class="citation">\cite{ISO19125,ISO191252}</span>. The developed system is using population and land use information stored in the database. This data is needed to estimate a subscribers start and end position within the boundaries of the cell coverage area. In addition to raster data (population and land use) the database also stores the OpenStreetMap road network. Figure [fig:pg<sub>s</sub>tructure] depicts the internal structure of the PostgreSQL database. The table <em>at<sub>2</sub>po<sub>4</sub>pgr</em> contains the OpenStreetMap road network, <em>landuse<sub>r</sub>aster</em> land use information and <em>density<sub>r</sub>aster</em> population information.</p>
<p><img src="./images/pg_structure" title="fig:" alt="Structure of the PostgreSQL database" /> [fig:pg<sub>s</sub>tructure]</p>
<h4 id="import-data">Import Data</h4>
<p>This section describes the process to import both raster and the a road network into the database. Raster data is simply an image where each pixel corresponds to a coordinate in world space. A raster image defines a grid spacing which defines how far in meters pixel are away. A grid spacing of <span class="LaTeX">$20$</span> meters means that each pixel covers an area of <span class="LaTeX">$400$</span> square meters. Usually environmental and demographic geographic information, is stored as a raster image. On the other hand road networks consists of a vector of points. The road network is stored in the database as Simple Features.</p>
<h5 id="raster">Raster</h5>
<p>To import raster data into the PostgreSQL database the tool <code>raster2pgsql</code> was used. Listing [lst:raster2pgsql] illustrates how to import the data. The parameter <code>s</code> defines the spatial reference system of the raster image. The grid spacing of the raster image is defined by parameter <code>t</code> and is in this case <span class="LaTeX">$100$</span> by <span class="LaTeX">$100$</span> meters. The tool converts the raster image into an SQL file which can be inserted into the database. To insert the created into the database the second command is used.</p>
<pre><code># raster2pgsql -s 4236 -I -C -M *.tif -F -t 100x100 population &gt; pop.sql
    # psql -U postgres -d gisdb -f pop.sql</code></pre>
<h5 id="road-network-1">Road Network</h5>
<p>Our system is using the routing engine osm2po which operates on the OpenStreetMap road network. Osm2po can convert the OpenStreetMap road network to a PostgreSQL compatible SQL file. Listing [lst:osm2pgsql] shows the step to import an OpenStreetMap road network – in this case from Austria – into the PostgreSQL database.</p>
<pre><code># java -jar osm2po-4_8_8.jar prefix=at austria.osm.pbf
    # psql -U postgres -d gisdb -f at/at_2po_4pgr.sql.sql</code></pre>
<h3 id="mysql-database">MySQL Database</h3>
<p>The developed system is using data from A1 and the OpenCoverageMap project. Because this data is not related with geographic information a second database is used to store this data. This information is stored in two separate tables because the structure of A1 and the OpenCoverageMap is different. Figure [fig:mysql<sub>s</sub>tructure] depicts the structure of the two tables, the first <em>mfd<sub>e</sub>vents</em> stores the A1 data and the second <em>ocm<sub>a</sub>ll</em> stores information from the OpenCoverageMap project.</p>
<p><img src="./images/mysql_structure" title="fig:" alt="Structure of the MySQL database" /> [fig:mysql<sub>s</sub>tructure]</p>
<h4 id="import-a1">Import A1</h4>
<p>To import the A1 data set into the MySQL, the binary event stream needs to be converted first. The conversion takes the binary event stream and converts its to CSV file. Each row in the CSV file represents an event. Later the created CSV file will be imported into the database similar to Listing [lst:textmysql].</p>
<h5 id="convert">Convert</h5>
<p>The conversion is carried out a by a Java program which takes the binary data stream as input and outputs a CSV file. First a Java <code>InputStream</code> from the input file will be created. This input stream will be passed to a <code>DataInputStream</code>. As illustrated in Listing [lst:parsestream] a loop iterates over the data input stream and parses the binary information according to the A1 data structure. At last at the end of each iteration the parsed information will be print to the standard output.</p>
<pre><code>// create file input stream
InputStream is = new FileInputStream(&quot;a1.data&quot;);
// create new data input stream
DataInputStream dis = new DataInputStream(is);
while (dis.available() != 0){
    byte[] anon_id = new byte[32];
    dis.read(anon_id);
    timestamp=dis.readInt();
    timestamp_ms=dis.readInt();
    lac=dis.readInt();
    cell_id=dist.readInt();
    latitude=dis.readDouble();
    longitude=dis.readDouble();
    radius= dis.readLong();
    dis.skipBytes(12); //skip reserved fields
    event_type = dis.readShort();
    dis.skipBytes(3); //skip reserved fields
    angle_x=dis.readInt();
    angle_y=dis.readInt();
    speed=dis.readInt();
    //only print useful fields
    System.out.println(Hex.encodeHexString(anon_id) +&quot;;&quot;+ timestamp +&quot;;&quot;+lac +&quot;;&quot;+cell_id +&quot;;&quot;+latitude +&quot;;&quot;+longitude +&quot;;&quot;+event_type +&quot;;&quot;+angle_x);
}</code></pre>
<pre><code>LOAD DATA INFILE &#39;data.txt&#39; INTO TABLE tbl_name
  FIELDS TERMINATED BY &#39;,&#39; ENCLOSED BY &#39;&quot;&#39;
  LINES TERMINATED BY &#39;\n&#39;;</code></pre>
<h4 id="import-opencoveragemap">Import OpenCoverageMap</h4>
<p>The data we got provided by the OpenCoverageMap project was already a CSV file and can be imported into the database with an SQL statement similar to the one in Listing [lst:textmysql].</p>
<h3 id="node.js-data-api">Node.js Data API</h3>
<p>To encapsulate the querying of the database from the trajectory service a Node.js API was implemented. It provides a HTTP API which gives access to the data stored in the PostgreSQL and MySQL database. The data API is using the following modules, which can be installed through the script provided in Listing [lst:nodemodules]:</p>
<ul>
<li><p><strong>express</strong><a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a> is a web application for Node.js and provides our system with web request routing in a RESTful manner</p></li>
<li><p><strong>pg</strong><a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a> is a PostgreSQL driver for Node.js</p></li>
<li><p><strong>mysql</strong><a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a> is a MySQL driver for Node.js</p></li>
</ul>
<pre><code># npm install express
    # npm install pg
    # npm install mysql</code></pre>
<pre><code>var pg = require(&#39;pg&#39;);

var conString = &quot;postgres://postgres:1234@localhost/postgres&quot;;
var mysql = require(&#39;mysql&#39;);
var connection = mysql.createConnection({
    host: &#39;localhost&#39;,
    user: &#39;mysql&#39;,
    password: &#39;1234&#39;
});

var express = require(&#39;express&#39;),
    app = express.createServer();

app.get(&#39;/mysql&#39;, function (req, res) {
    connection.connect();
    connection.query(&#39;SELECT 1 + 1 AS result&#39;, function (err, rows, fields) {
        res.send(rows[0].solution);
    });
    connection.end();
});

app.get(&#39;/postgres&#39;, function (req, res) {
    var client = new pg.Client(conString);
    client.connect(function (err) {
        client.query(&#39;SELECT NOW() AS time&#39;, function (err, result) {
            res.send(result.rows[0].time);
        });
    });
});

app.listen(3000);</code></pre>
<h4 id="features">Features</h4>
<p>The Node.js provides several features to the trajectory service. It enables the trajectory service to access the two database via an uniform API. This API hides the implementation from the using program. However, to increase performance the API was split into two parts. The first API resides on the same server as the PostgreSQL and handles geographic request whereas the second one handles subscription data and resides on the MySQL server.</p>
<h5 id="mysql-api">MySQL API</h5>
<p>provides access to mobile subscription data for both the A1 and OpenCoverageMap data. In addition, the route traveled by a subscriber can be retrieved from the OpenCoverageMap data. This route consists of a timestamp and the latitude and longitude coordinate. All the returned data is encoded as JSON that eases the parsing. Listing [lst:mysqlapireq] depicts the request that can be made to the database. The first one retrieves events from A1 for the specified user, the second one retrieves events from OpenCoverageMap and the last one get the route traveled by the OpenCoverageMap user.</p>
<pre><code>GET /mfdevents?id=USER_ID
GET /ocmraw?id=USER_ID
GET /ocmroute?id=USER_ID</code></pre>
<h5 id="postgresql-api">PostgreSQL API</h5>
<p>enables the requesting program to access functions of the PostgreSQL database. It provides access to raster data as population and land use information as well as to retrieve a random point withing a specified area based on population and land use information (see Listing [pgapireq]). The bounds parameter is encoded as a list of coordinate – separated by a comma – specifying a bounding box (xmin,ymin,xmax,ymax). In comparison the geom parameter is encoded as Well-known text (WKT) which allows defining more advanced areas as polygons and multi polygons (POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10)) ).</p>
<pre><code>GET /populationBounds?bounds=BOUNDARIES
GET /landuseBounds?bounds=BOUNDARIES
GET /randomgeom?geom=GEOMETRY&amp;num=NUMBER_OF_POINTS</code></pre>
<h3 id="routing-engine">Routing Engine</h3>
<p>To calculate routes on the OpenStreetMap road network, the system is using the osm2po routing engine. This engine can either be used as a standalone web server with a defined API or be integrated into a Java application. In our case the engine was integrated into the trajectory service as a library. The benefit of this approach is, that the system has better access to the graph file used by the engine. The graph file is a reduced road network optimized for routing. By accessing the graph file, the trajectory service can retrieve metadata for the calculated route such as speed limits and length of the roads. This information can later be used to validate the calculate route and the timing information.</p>
<p>Listing [lst:osm2po] illustrates how a route between Linz and Hagenberg im Mühlkreis is calculated. The result is an array with segment IDs that can then be used to retrieve the geometry and the speed limits of the segment from the graph file.</p>
<pre><code>File graphFile = new File(&quot;at_2po_4pgr.gph&quot;);
Graph graph = new Graph(graphFile);
DefaultRouter router = new DefaultRouter();

//Linz, Austria
int sourceId = graph.findClosestVertexId(48.306f,14.285f);
//Hagenberg im Mühlkreis, Austria
int targetId = graph.findClosestVertexId(48.368f,14.513f);

Properties params = new Properties();
params.setProperty(&quot;findShortestPath&quot;, &quot;false&quot;);

//calculate path between source and target
int[] path = router.findPath(
    graph, sourceId, targetId, Float.MAX_VALUE, params);</code></pre>
<h3 id="trajectory-service">Trajectory Service</h3>
<p>The trajectory service is using the above mentioned data and APIs to generate trajectories for each subscriber. By using different data sources it can estimate trajectories for different data providers in our case mobile network operators. In the current state trajectories can be generated for A1 subscriber and OpenCoverageMap participants. To fulfill its task the trajectory service needs besides the events from the network operator a coverage prediction for each cell site. The trajectory service is using the following data:</p>
<ul>
<li><p>Mobile subscription data</p></li>
<li><p>Population and land use information</p></li>
<li><p>Cell site coverage prediction</p></li>
<li><p>OpenStreetMap road network</p></li>
<li><p>osm2po route engine</p></li>
</ul>
<h4 id="convert-events">Convert Events</h4>
<p>The structure of events used in the trajectory generator was inspired by the structure used in the A1 event stream. To integrate other data sources such as the OpenCoverageMap a converted needs to be implemented. The objective of the converter is to transform the event structure to the one used by A1 events.</p>
<p>The OpenCoverageMap doesn’t use the same event structure as A1. Rather than issuing events like call establish / termination or hand over it periodically stores the state of the mobile station. Therefore, this information needs to be transformed to an event structure. The steps to convert the OpenCoverageMap data to the A1 structure are the following: First remove all data where no call is active. Second iterate over this data and check for gaps between succeeding timestamps. Gaps greater than 10 seconds indicate that a call was either established or terminated. Afterwards iterate over the data between two gaps. Create a call establish and termination event at the beginning and end of the list. If there is a difference between the cell-id and location area of two succeeding entries add a hand over event to the current call. The result will be a list of events with the same structure as the ones captured by A1.</p>
<h2 id="trajectory-service-1">Trajectory Service</h2>
<p>The generation of subscriber trajectories involves a number of steps which have to be carried. In this section, an overview of all processes involved in the generation will be explained. In general, the processes can be divided into 4 categories: <em>data retrieval</em>,<em>processing</em>,<em>validation</em>,<em>presentation</em>.</p>
<h3 id="start-and-end-position">Start and End Position</h3>
<h3 id="route-validation">Route Validation</h3>
<h4 id="geometry">Geometry</h4>
<h4 id="timing">Timing</h4>
<h3 id="timing-information">Timing Information</h3>
<h4 id="handover-prediction">Handover Prediction</h4>
<h1 id="results">Results</h1>
<h2 id="routing-1">Routing</h2>
<h2 id="timing-1">Timing</h2>
<h3 id="rural">Rural</h3>
<h4 id="cluster">Cluster</h4>
<h4 id="cell">Cell</h4>
<h4 id="hybrid">Hybrid</h4>
<h3 id="urban">Urban</h3>
<h4 id="cluster-1">Cluster</h4>
<h4 id="cell-1">Cell</h4>
<h4 id="hybrid-1">Hybrid</h4>
<h3 id="highway">Highway</h3>
<h4 id="cluster-2">Cluster</h4>
<h4 id="cell-2">Cell</h4>
<h4 id="hybrid-2">Hybrid</h4>
<h2 id="handover-positions">Handover Positions</h2>
<h1 id="discussion">Discussion</h1>
<h1 id="summary">Summary</h1>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Press conference by the Forum Mobilkommunication <a href="http://www.fmk.at/Medien/Pressekonferenzen/FMK-Jahrespressekonferenz-2012">press conference link</a><a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Project website: <a href="http://www.ftw.at/forschung-innovation/projekte/roadcell">http://www.ftw.at/forschung-innovation/projekte/roadcell</a> last accessed March 12 2014<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>CORINE: “Coordination of Information on the Environment”; <a href="http://www.eea.europa.
eu/publications/COR0-landcover">http://www.eea.europa.
eu/publications/COR0-landcover</a>, last accessed on March 11,2014<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p><a href="http://www.data.gv.at/datensatz/?id=9246f37d-da69-4442-9504-ebd006a059bb">http://www.data.gv.at/datensatz/?id=9246f37d-da69-4442-9504-ebd006a059bb</a>, last accessed on March 11,2014<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Image source: <a href="http://www.eea.europa.eu/data-and-maps/figures/corine-land-cover-2000-by-country/clc00_at_national.eps/image_original">http://www.eea.europa.eu/data-and-maps/figures/corine-land-cover-2000-by-country/clc00_at_national.eps/image_original</a>l, last accessed on March 11,2014.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p><a href="http://www.eea.europa.eu/data-and-maps/data/population-density-disaggregated-with-
	corine-land-cover-2000-2">http://www.eea.europa.eu/data-and-maps/data/population-density-disaggregated-with-
	corine-land-cover-2000-2</a>, last accessed on March 11,2014<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p><a href="http://www.openstreetmap.org/about">http://www.openstreetmap.org/about</a>, last accessed on March 12, 2014<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>Image source: <a href="http://render.openstreetmap.org/cgi-bin/export?bbox=14.278879165649414,48.31028478774528,14.302825927734377,48.320590159843626&amp;scale=5754&amp;format=pdf">http://render.openstreetmap.org/cgi-bin/export?bbox=14.278879165649414,48.31028478774528,14.302825927734377,48.320590159843626&amp;scale=5754&amp;format=pdf</a>, last accessed on March 12, 2014<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>Data source: <a href="http://www.eea.europa.eu/data-and-maps/data/ds_resolveuid/ca503256de1b4231b029e4145d0a8b7b">http://www.eea.europa.eu/data-and-maps/data/ds_resolveuid/ca503256de1b4231b029e4145d0a8b7b</a> last accessed March 19, 2014<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>Project description: <a href="http://www.senderkataster.at/">http://www.senderkataster.at/</a> last accessed March 19, 2014<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>Projection string: <a href="http://spatialreference.org/ref/sr-org/7397/html/">http://spatialreference.org/ref/sr-org/7397/html/</a> last accessed March 19, 2014<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>Project description: <a href="http://osm2po.de/">http://osm2po.de/</a>, last accessed on March 18,2014<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>Image source: <a href="http://en.wikipedia.org/wiki/File:Hausdorff_distance_sample.svg">http://en.wikipedia.org/wiki/File:Hausdorff_distance_sample.svg</a> last accessed on March 16, 2014<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>PostgreSQL JDBC driver: <a href="http://jdbc.postgresql.org/">http://jdbc.postgresql.org/</a>, last accessed March, 28 2014<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>MySQL JDBC driver: <a href="https://dev.mysql.com/downloads/connector/j/">https://dev.mysql.com/downloads/connector/j/</a>, last accessed March, 28 2014<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p>Project website with more information about express: <a href="http://expressjs.com">http://expressjs.com</a>, last accessed March 28, 2014<a href="#fnref16">↩</a></p></li>
<li id="fn17"><p>More information about the PostgreSQL driver pg: <a href="https://github.com/brianc/node-postgres">https://github.com/brianc/node-postgres</a>, last accessed March 28, 2014<a href="#fnref17">↩</a></p></li>
<li id="fn18"><p>Project website with more information and a tutorial about mysql: <a href="https://github.com/felixge/node-mysql">https://github.com/felixge/node-mysql</a>, last accessed March 28, 2014<a href="#fnref18">↩</a></p></li>
</ol>
</div>
</body>
</html>
